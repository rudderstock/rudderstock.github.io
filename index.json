[{"content":"tags:: vue, react\n本文主要面向 react 开发人员快速上手 vue 的 .tsx 组件开发\nTsx 在 vue 项目中，如果不太熟悉、不想使用 vue 模板语法的开发方式，可以通过 vite 相关插件，使用 tsx 进行组件编写\n优点：\n可以使用更加灵活的 jsx 来进行开发 logseq.order-list-type:: number\n可以单个文件里可以输出多个小组件 logseq.order-list-type:: number\n更加灵活的js配置，不需要忍受 .vue 模版里的的魔法配置 logseq.order-list-type:: number\n减少 all in one（页面组件代码 4000 + 行） 概率，文件内可以各种变量导出，重复内容也可以很方便的进行管理 logseq.order-list-type:: number\n使用 model.confirm 等函数方式调用组件，可以很方便的个性化自定义标签，不需要频繁塞进 template 里，再声明 ref 来进行各种控制 logseq.order-list-type:: number\n缺点：\n无法使用 css scope，可以使用 css-modules 或者其他方式来进行样式隔离，习惯了 :deep 等方式的开发人员可能会不太适应 logseq.order-list-type:: number\n其他成员难维护，未接触过 react 框架的 vue 开发人员，大概率无法接受和学习开发，需要靠你自己维护或者培训他们 logseq.order-list-type:: number\n.tsx 引用自己项目创建的 .vue 的组件，没有相关类型声明，需要自己手动或者通过其他手段添加声明类型 logseq.order-list-type:: number\nvue 重点还是放在 .vue 组件，后续 .tsx 更新优化力度不会太大 logseq.order-list-type:: number\nref.value 这个 .value 使用时还是有点烦，绑定时经常需要注意 logseq.order-list-type:: number\nBabel 设置 安装相关插件 npm i @vitejs/plugin-vue-jsx -D vite.config.ts // vite.config.js import vueJsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39; export default { plugins: [ vueJsx({ // options are passed on to @vue/babel-plugin-jsx }), ], } 创建组件 有以下几种方式创建组件 // 选项语法 function defineComponent( component: ComponentOptions ): ComponentConstructor // 函数语法 (需要 3.3+) function defineComponent( setup: ComponentOptions[\u0026#39;setup\u0026#39;], extraOptions?: ComponentOptions ): () =\u0026gt; any // 函数组件 export const Button = props =\u0026gt; { return \u0026lt;div\u0026gt;{props.name}\u0026lt;/div\u0026gt;; }; defineComponent 可以通过创建 props 变量，进行管理和复用\n选项语法和函数语法只是写法不一样，看个人习惯\nconst ButtonProps = { name: { type: String, default: \u0026#39;hello\u0026#39; } } // 函数语法 export default defineComponent((props, { emit }) =\u0026gt; { return () =\u0026gt; { return \u0026lt;div\u0026gt;{props.name}\u0026lt;/div\u0026gt;; }; }, { props: ButtonProps }); // 选项语法 export const Button = defineComponent({ props: ButtonProps, setup(props, ctx) { return () =\u0026gt; { return \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } } }) 函数组件 该方式无法函数内创建 State，能不用就不用，只适用于非常简单的组件，例如下面示例： import { ref } from \u0026#39;vue\u0026#39; const RcButton = () =\u0026gt; { const count = ref(0) function onClick() { count.value++ } return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; 数字 : {count.value}\u0026lt;/div\u0026gt; \u0026lt;button onClick={onClick}\u0026gt;点我+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } + 点击按钮后，视图仍然显示为 0，点击事件无任何作用 是否能使用 React.FC\u0026lt;Props\u0026gt; 方式创建函数组件 是否能像 const component: FC\u0026lt;Props\u0026gt; = (props) =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 快速生成组件\n只能说，看起来可以，但基本上不行，还是要写传统的 Props 变量来进行约束，如下所示：\ndefineComponent 看起来似乎可以传定义过去，而且使用时，编辑器也有相关提示 import { defineComponent } from \u0026#39;vue\u0026#39; interface ButtonProps { type: \u0026#39;primary\u0026#39; | \u0026#39;ghost\u0026#39;, content: string } export default defineComponent\u0026lt;ButtonProps\u0026gt;((props) =\u0026gt; { return () =\u0026gt; { return \u0026lt;div\u0026gt;{props.content}\u0026lt;/div\u0026gt; } }) + 但组件使用后，传的值并没有传到 `props` 上，而是 `attrs` 上，只是看起来像生效了而已 + ## FunctionalComponent + 虽然可以通过泛型来快速定义，`props` 也有值，编辑器有类型提示，但无法定义 `State`，基本上无用 interface ButtonProps { type: string } const RcButton: FunctionalComponent\u0026lt;ButtonProps\u0026gt; = (props, { attrs }) =\u0026gt; { console.log(\u0026#39;props\u0026#39;, props) console.log(\u0026#39;attrs\u0026#39;, attrs) return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{props.type}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } + `props` 和 `attrs` 传值一样，将就的话怎么说也能用 基本使用 如下所示：简单的点击按钮，数字加一 import { defineComponent, type PropType } from \u0026#39;vue\u0026#39; import { useVModel } from \u0026#39;@vueuse/core\u0026#39; export default defineComponent({ props: { type: String as PropType\u0026lt;\u0026#39;primary\u0026#39; | \u0026#39;warning\u0026#39;\u0026gt;, modelValue: { type: Number, required: true } }, emits: [\u0026#39;update:modelValue\u0026#39;], setup(props, { emit }) { const count = useVModel(props, \u0026#39;modelValue\u0026#39;, emit, { defaultValue: 0 }) function onButtonClick() { count.value += 1 } return () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;数字是 {count.value}\u0026lt;/div\u0026gt; \u0026lt;button onClick={onButtonClick}\u0026gt;点我+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } } }) 使用下来，结构上大概可以分三个区域： 第一区域：用于定义 props、emit、slots 等相关外部属性； logseq.order-list-type:: number\n第二区域：用于定义声明 state 组件内部状态，比如创建各种变量、ref、watch、computed 等相关操作，一些性质类似于 React.Component 的 constructor，可以定义类型，只执行一次，不过能添加 watch，生命周期等相关操作； logseq.order-list-type:: number\n第三区域：可以理解为 render 的函数，只要发生渲染，就会执行； logseq.order-list-type:: number\n刚开始接触 .tsx 可能很难绕过来弯，初次上手，可以 setup 下当成 constructor 来使用，应该能稍微好上手一点。\n后续 ","permalink":"https://rudderstock.github.io/pages/react-vue-tsx-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"tags:: vue, react\n本文主要面向 react 开发人员快速上手 vue 的 .tsx 组件开发\nTsx 在 vue 项目中，如果不太熟悉、不想使用 vue 模板语法的开发方式，可以通过 vite 相关插件，使用 tsx 进行组件编写\n优点：\n可以使用更加灵活的 jsx 来进行开发 logseq.order-list-type:: number\n可以单个文件里可以输出多个小组件 logseq.order-list-type:: number\n更加灵活的js配置，不需要忍受 .vue 模版里的的魔法配置 logseq.order-list-type:: number\n减少 all in one（页面组件代码 4000 + 行） 概率，文件内可以各种变量导出，重复内容也可以很方便的进行管理 logseq.order-list-type:: number\n使用 model.confirm 等函数方式调用组件，可以很方便的个性化自定义标签，不需要频繁塞进 template 里，再声明 ref 来进行各种控制 logseq.order-list-type:: number\n缺点：\n无法使用 css scope，可以使用 css-modules 或者其他方式来进行样式隔离，习惯了 :deep 等方式的开发人员可能会不太适应 logseq.order-list-type:: number\n其他成员难维护，未接触过 react 框架的 vue 开发人员，大概率无法接受和学习开发，需要靠你自己维护或者培训他们 logseq.order-list-type:: number","title":"react-vue-tsx 基本使用"}]